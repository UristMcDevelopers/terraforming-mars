-- script for grid state + proxy message to ui

local C = require "utils.message_ids"
local UTILS = require "utils.helpers"
local GRID_UTILS = require "hex_grid.hex_grid_utils"
local ASSERTS = require "utils.assertions"

local IMAGE_EMPTY_OCEAN = "Empty_ocean"
local tile_type_to_image = {
	[C.TILE_TYPE_OCEAN] = "Ocean", 
	[C.TILE_TYPE_TREE] = "Tree", 
	[C.TILE_TYPE_CITY] = "City", 
}
local resource_to_image = {
	[C.RECOURCE_PLANT] = "Plant",
	[C.RECOURCE_STEEL] = "Steel", 
	[C.RECOURCE_TITANIUM] = "Titanium", 
	[C.PLAYER_DRAW_CARD] = "Draw", 
}

local ocean_coords = {[1] = {7}, [4] = {7,8,9}, [5] = {4,5,6}, [6] = {9}, [8] = {8}, [9] = {4,6,7}}
local non_mars_coords = {[8] = {1}, [9] = {1}}
local noctis_city = {[5] = {3}}
local placed_tiles_coords = {}
local placement_bonuses_coords = { -- TODO вынести в файл
	[1] = { 
		[3] = { C.RECOURCE_STEEL },
		[4] = { C.RECOURCE_STEEL, C.RECOURCE_STEEL },
		[7] = { C.RECOURCE_TITANIUM, C.RECOURCE_TITANIUM },
	},
	[2] = {
		[3] = { C.RECOURCE_STEEL, C.RECOURCE_STEEL },
		[5] = { C.PLAYER_DRAW_CARD },
		[6] = { C.PLAYER_DRAW_CARD },
		[8] = { C.RECOURCE_TITANIUM },
	},
	[3] = {
		[7] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
	},
	[4] = {
		[2] = { C.RECOURCE_PLANT },
		[3] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[4] = { C.RECOURCE_PLANT },
		[5] = { C.RECOURCE_PLANT },
		[6] = { C.RECOURCE_PLANT },
		[7] = { C.RECOURCE_PLANT },
		[8] = { C.RECOURCE_PLANT },
		[9] = { C.RECOURCE_PLANT },
	},
	[5] = {
		[1] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[2] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[3] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[4] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[5] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[6] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[7] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[8] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
		[9] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
	},
	[6] = {
		[2] = { C.RECOURCE_PLANT, C.RECOURCE_STEEL },
		[3] = { C.RECOURCE_PLANT },
		[4] = { C.RECOURCE_PLANT },
		[5] = { C.RECOURCE_PLANT },
		[6] = { C.RECOURCE_PLANT },
		[7] = { C.RECOURCE_PLANT },
		[8] = { C.RECOURCE_PLANT },
		[9] = { C.RECOURCE_PLANT, C.RECOURCE_PLANT },
	},
	[7] = { 
		[2] = { C.PLAYER_DRAW_CARD },
		[8] = { C.RECOURCE_STEEL },
	},
	[8] = { 
		[4] = { C.RECOURCE_STEEL },
		[8] = { C.PLAYER_DRAW_CARD, C.PLAYER_DRAW_CARD },
	},
	[9] = { 
		[3] = { C.RECOURCE_STEEL, C.RECOURCE_STEEL },
		[4] = { C.RECOURCE_STEEL, C.RECOURCE_STEEL },
		[6] = { C.PLAYER_DRAW_CARD },
	},
	
}


local function is_ocean_place(row, column)
	return ocean_coords[row] and UTILS.array_has_value(ocean_coords[row], column)
end


local function is_non_mars_place(row, column)
	return non_mars_coords[row] and UTILS.array_has_value(non_mars_coords[row], column)
end

local function is_city_place(row, column)
	return noctis_city[row] and UTILS.array_has_value(noctis_city[row], column)
end

local function is_tile_taken(row, column)
	return placed_tiles_coords[row] and placed_tiles_coords[row][column]
end


local function update_placed_tiles(row, column, message)
	local row_talbe = placed_tiles_coords[row]
	local tile_info = { player_id = 1, type = message.type }
	if row_talbe == nil then
		placed_tiles_coords[row] = { [column] = tile_info }
	else 
		row_talbe[column] = tile_info
	end
	-- print(placed_tiles_coords[row][column].type)
end

local function neighbor_tiles_count(row, column)
	if is_city_place(row, column) then
		return 0, 0
	end
	local cities = 0
	local oceans = 0
	local tiles = GRID_UTILS.neighbor_tiles(placed_tiles_coords, row, column)
	for i, tile_info in pairs(tiles) do
		if tile_info.type == C.TILE_TYPE_CITY then
			cities = cities + 1
		elseif tile_info.type == C.TILE_TYPE_OCEAN then
			oceans = oceans + 1
		end
	end
	return cities, oceans
end

local function set_map_recources()
	for row_index, column_indexes in pairs(placement_bonuses_coords) do
		for column_index, resource_list in pairs(column_indexes) do
			if #resource_list > 0 then
				local resource_images = {}
				for index, value in ipairs(resource_list) do
					table.insert(resource_images, index, resource_to_image[value]) 
				end
				msg.post("#hex_grid_ui", C.MAP_SET_TILE_RECOURCES, {
					row = row_index,
					column = column_index,
					resources = resource_images
				})
			end
		end
	end
end

local function set_map_oceans()
	for row_index, column_indexes in pairs(ocean_coords) do
		for k, column_index in pairs(column_indexes) do
			msg.post("#hex_grid_ui", C.MAP_SET_TILE, {
				image_name = IMAGE_EMPTY_OCEAN, 
				row = row_index, 
				column = column_index, 
				player_color = C.TRANSPARENT_COLOR
			})
		end
	end
end

function init(self)
	set_map_recources()
	set_map_oceans()
end


function on_message(self, message_id, message, sender)
	if message_id == hash(C.MAP_SET_TILE) then
		local row = message.row
		local column = message.column
		local tile_type = message.type
		
		ASSERTS.positive_number(row)
		ASSERTS.positive_number(column)
		assert(message.player_color)
		assert(tile_type)
		
		--TODO add validations
		if is_tile_taken(row, column) then
			error("tile is already taken")
		end
		local close_cities, close_oceans = neighbor_tiles_count(row, column)
		if tile_type ~= C.TILE_TYPE_OCEAN and is_ocean_place(row, column) then
			error("only ocean on ocean tile")
		end
		if tile_type == C.TILE_TYPE_OCEAN and not is_ocean_place(row, column) then
			error("ocean can be placed only in ocean tile")
		end
		if tile_type ~= C.TILE_TYPE_CITY and is_non_mars_place(row, column) then
			error("only city on this tile")
		end
		if tile_type == C.TILE_TYPE_CITY and not is_non_mars_place(row, column) then
			if close_cities > 0 then
				error("has neigbor city")
			end
		end
		
		if close_oceans > 0 then
			print("neigbor oceans", close_oceans)
			--TODO send 2 gold per tile to player who put tile
		end
		
		--TODO add state change
		update_placed_tiles(message.row, message.column, message)
		
		message.image_name = tile_type_to_image[tile_type]
		msg.post("#hex_grid_ui", C.MAP_SET_TILE, message)
		msg.post(sender, C.MAP_SET_TILE, message)
	end
	
end
